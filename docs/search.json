[
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introduction",
    "section": "",
    "text": "Random walks are a commonly used tool in the arsenal of algorithms on Classical Computers to solve a variety of problems which do not have a known easy solution. The power of such methods can generally be attributed to the fact that while the space of possible solutions is vast, we generally only need to sample few solutions to come to a close solution. This power has been routinely exploited in the past to sample from Markov Chains using the MCMC algorithm which can be found in any introductory textbook1 of markov processes, and they have recently been used in the fields of Financial engineering2, fluid mechanics3, fitting blackhole images4 and most famously in the Los Alamos project5.\nWith the advent of quantum algorithms, quantum walks have arisen as an obvious extension of classical walks in the quantum domain. The applications of quantum walks are just as many: ANN training6, Random Number Generation7, List coloring (Grover)8, collision finding9, link prediction10. There has even been a recent foray into classifying and using a quantum-classical walk to speed up certain classical algorithms, namely the Google PageRank Algorithm11. The increased interest in quantum walks can be attributed to the quadratic speed up which it grants the solution a-la the Grover algorithm, which itself can be considered as a Quantum Walk12. While there is also interest in studying the physical implementation of the walks, we do not concern ourselves with these questions, since experimentalists are much better equipped to ask them.\nIn this master thesis, we will define both the classical (?sec-classical) and quantum (?sec-quantum) walks along with certain properties that are, while interesting in their own regard, problematic for search algorithms (?sec-search). Then, we look at previous attempts at solving them by resetting (?sec-reset), and discuss the shortcomings of the solution. Finally, we introduce a new mechanism (?sec-qreset) which we believe is more general and may show interesting phenomena with particular advantage in the search problem.\nAlong with the theory, certain aspects of the implementation of the walks computationally are also added as necessary. This is done inline instead of in an appendix, which is the norm, since the author believes that such a presentation solidifies the readers’ understanding of both, the model and the implementation.\n\n\n\n\n\n\n1 J.R. Norris, Markov Chains, 1st pbk. ed (Cambridge University Press, Cambridge, UK ; New York, 1998).\n\n\n2 P. Glasserman, Monte Carlo Methods in Financial Engineering (Springer, New York, 2004).\n\n\n3 K.P. Griffin, S.J. Suresh, T.J. Flint, and W.H.R. Chan, (2019).\n\n\n4 D. Psaltis, F. Özel, L. Medeiros, P. Christian, J. Kim, C. Chan, L.J. Conway, C.A. Raithel, D. Marrone, and T.R. Lauer, ApJ 928, 55 (2022).\n\n\n5 N. Metropolis, (n.d.).\n\n\n6 L.S. de Souza, J.H.A. de Carvalho, and T.A.E. Ferreira, in 2019 8th Brazilian Conference on Intelligent Systems (BRACIS) (IEEE, Salvador, Brazil, 2019), pp. 836–841.\n\n\n7 M. Bae and W.O. Krawec, (2021).\n\n\n8 S. Mukherjee, IEEE Trans. Quantum Eng. 3, 1 (2022).\n\n\n9 X. Bonnetain, A. Chailloux, A. Schrottenloher, and Y. Shen, (2022).\n\n\n10 M. Goldsmith, G. García-Pérez, J. Malmi, M.A.C. Rossi, H. Saarinen, and S. Maniscalco, (2022).\n\n\n11 S.A. Ortega and M.A. Martin-Delgado, (2022).\n\n\n12 Qiskit, Quantum Walk Search Algorithm (n.d.)."
  },
  {
    "objectID": "classical.html#definition",
    "href": "classical.html#definition",
    "title": "3  Classical Walks{#sec-classical}",
    "section": "3.1 Definition",
    "text": "3.1 Definition\nConsider an infinite 1 D chain, with nodes marked by \\(\\mathbb{Z}\\).\n\n\n\n\n\nFigure 3.1: 1 D Chain\n\n\n\n\nDefine the probability of hopping from node \\(i\\) to node \\(j\\)\n\\[p_{ij} = \\begin{cases}\n    1/2 & |i - j| = 1 \\\\\n    0 & \\text{otherwise}\n\\end{cases}\\]\nAnd the initial state as\n\\[\\lambda_{ij} = \\begin{cases}\n    1 & i = 0 \\\\\n    0 & \\text{otherwise}\n\\end{cases}\\]\nThus, the hopper can only move to it nearest neighbors, starting from node 0.\nNote that \\(P(X_t = i | \\text{ HISTORY }) = P(X_t = i | X_{t-1})\\), which means that the walk is a markov chain."
  },
  {
    "objectID": "classical.html#multiple-walkers",
    "href": "classical.html#multiple-walkers",
    "title": "3  Classical Walks{#sec-classical}",
    "section": "3.2 Multiple Walkers",
    "text": "3.2 Multiple Walkers\nThe SSRW is clearly a stochastic process, and each run of this process will lead to different paths being chosen by the walker, and we are my interested in what the walker does on an average rather than what happens in a particular instance. Thus, we can observe multiple walks, and plot their paths to visualize how they would spread.\nIn order to simulate a walk, we sample \\(X_i \\in \\{-1, 1\\}\\) with equal probability, and add it to the previous position \\(S_{i-1}\\) to get \\(S_i\\). Note \\(S_0 = 0\\). Thus, this is equivalent to sampling from [1, -1] uniformly t times and performing a cumulative sum. For n walkers, we can sample (t, n) such random numbers, and do a cumulative sum along the first dimension.\n\nbm = cumsum(rand([1, -1], (200, 15)), dims=1);\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.2: An ensemble of classical walkers"
  },
  {
    "objectID": "classical.html#probability-mass-function",
    "href": "classical.html#probability-mass-function",
    "title": "3  Classical Walks{#sec-classical}",
    "section": "3.3 Probability mass function",
    "text": "3.3 Probability mass function\nAnother common way to visualize the walk is to plot the probability that the walker is on node \\(i\\) at time \\(t\\). For this, we simply define the transition matrix and \\(\\lambda\\) appropriately and find \\(\\lambda P^t\\). Note however that the transition matrix for the SSRW is Tridiagonal with the Upper and Lower diagonals as 0.5 and the diagonal as 0, and there exist efficient storage and multiplication routines. Also, since we can only store a finite matrix, we limit the walk to some size. At the boundaries, we simply allow open conditions, because this is the easiest to implement.\n\ncps, cps_t = let \n    t = 21\n    U = SymTridiagonal(fill(0., 31), fill(0.5, 30))\n    λ = fill(0., 31)\n    λ[16] = 1\n    ps = accumulate(1:t, init=λ) do old, _\n        U * old\n    end[t÷3:t÷3:t], t÷3\nend;\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.3: Probability distribution of a classical walker in time"
  },
  {
    "objectID": "classical.html#properties-of-the-walk",
    "href": "classical.html#properties-of-the-walk",
    "title": "3  Classical Walks{#sec-classical}",
    "section": "3.4 Properties of the walk",
    "text": "3.4 Properties of the walk\nThere are certain properties of the walk that are interesting for the problem we pose in the subsequent sections. Primarily, we are interested in the mean, standard deviation and recurrence of the graph.\nThe probability that a walker is on node \\(n\\) at time \\(t\\) is given by the expression\n\\[p(n, t) = \\binom{t}{\\frac{t+n}{2}} \\frac{1}{2^t}\\]\nThis equation is valid only if \\(t + n\\) is even and \\(n \\le t\\). If \\(t + n\\) is odd or \\(n &gt; t\\), the probability is zero\nIt should be obvious from the even symmetry of \\(p(n, t)\\) that the mean \\(\\mu(t) = \\sum_n np(n,t) = 0\\). This comes from the fact that the walk is symmetric.\nThe standard deviation of the walker position \\(\\sigma(t) = \\sqrt{\\langle n^2 \\rangle - \\langle n\\rangle^2} = \\sqrt{\\sum_n n^2p(n,t)} = \\sqrt t\\)1.\n\n\n\n\n\n\n1 R. Portugal, Quantum Walks and Search Algorithms, 2nd ed. 2018 (Springer International Publishing : Imprint: Springer, Cham, 2018)."
  },
  {
    "objectID": "quantum.html#introduction",
    "href": "quantum.html#introduction",
    "title": "4  Quantum Walks{#sec-quantum}",
    "section": "4.1 Introduction",
    "text": "4.1 Introduction\nQuantum walks are defined analogous to the classical walks.\nFirst, our walker is quantum mechanical, and the position of the walker can be a superposition of the nodes. Thus, we define the state of the walker to be a superposition of the node states \\(|i\\rangle\\).\n\\[|\\psi\\rangle = \\sum_i c_i|i\\rangle\\]\nLet this Hilbert space be denoted as \\(\\mathcal{H}_W\\). The projection of the state on some node \\(i\\) given by \\(|\\langle i | \\psi\\rangle|^2 = |c_i|^2\\) is understood as the probability that the walker will collapse to the state \\(|i\\rangle\\) on measurement.\nTo define the evolution of the node, we look back at the transition matrix \\(P_{ij}\\). Thus we would define an operation in the following manner -\n\\[O |i\\rangle = \\sum_j \\sqrt{p_{ij}} |j\\rangle\\]\nand the walk proceeds by repeated application of \\(O\\).\nWhile this expression is enough to define the walk, it is not immediately clear how one would explicitly realize such an operation. There are multiple formalisms to define such walks, but we shall use the coined quantum walk formalism which is very natural for regular graphs, as is the case for the 1D chain. Note that for the symmetric walks on nD lattices, like the 1D chain, the tight-binding model is already a well understood continous time quantum walk. However, we prefer a discrete time formalism."
  },
  {
    "objectID": "quantum.html#coined-quantum-walk-for-1d-chain",
    "href": "quantum.html#coined-quantum-walk-for-1d-chain",
    "title": "4  Quantum Walks{#sec-quantum}",
    "section": "4.2 Coined Quantum Walk for 1D Chain",
    "text": "4.2 Coined Quantum Walk for 1D Chain\nFor the 1D chain, given a specific node, there are only 2 other nodes connected to it. Thus, we can add a 2 level system, which “decides” which node the walker jumps to. More formally, we attach a 2 level qubit system to the walker whose bases are denoted by \\(|0\\rangle\\) and \\(|1\\rangle\\). Let us denote this hilbert space as \\(\\mathcal{H}_C\\)\nThus, we can define the shift operation as\n\\[S |0\\rangle|i\\rangle = |0\\rangle|i-1\\rangle; S |1\\rangle|i\\rangle = |1\\rangle|i+1\\rangle\\]\nHow would we define such an operation explicitly?\n\\[S = |0\\rangle\\langle 0|\\otimes S_L + |1\\rangle\\langle 1|\\otimes S_R\\]\nWhere \\(S_L\\) and \\(S_R\\) are defined as\n\\[S_L |i\\rangle = |i-1\\rangle,\\ S_R |i\\rangle = |i+1\\rangle\\]\nNote that \\(S\\) operates on \\(\\mathcal{H}_C\\otimes\\mathcal{H}_W\\), whereas \\(S_L\\) and \\(S_R\\) operate on \\(\\mathcal{H}_W\\) only.\nThe superposition in the two choices at each step is recovered by putting the coin into a superposition of its basis states. This is achieved via a coin operator, which is commonly defined as \\(H\\otimes I\\), where \\(H\\) is the single qubit hadamard operator.\nLet us explicitly write down two steps of the walk\n\\[H\\otimes I (|0\\rangle |0\\rangle) = \\frac{|0\\rangle |0\\rangle + |1\\rangle |0\\rangle}{\\sqrt 2}\\] \\[S\\left(\\frac{|0\\rangle |0\\rangle + |1\\rangle |0\\rangle}{\\sqrt 2}\\right) = \\frac{|0\\rangle |-1\\rangle + |1\\rangle |1\\rangle}{\\sqrt 2}\\] \\[H\\otimes I \\frac{|0\\rangle |-1\\rangle + |1\\rangle |1\\rangle}{\\sqrt 2} = \\frac{|0\\rangle |-1\\rangle + |1\\rangle |-1\\rangle + |0\\rangle |1\\rangle - |1\\rangle |1\\rangle}{2}\\] \\[S \\frac{|0\\rangle |-1\\rangle + |1\\rangle |-1\\rangle + |0\\rangle |1\\rangle - |1\\rangle |1\\rangle}{2} = \\frac{|0\\rangle |-2\\rangle + (|1\\rangle + |0\\rangle) |0\\rangle - |1\\rangle |2\\rangle}{2}\\]\n\n\n\n\n\n\nRepeated application of Coin Operator\n\n\n\nNote specifically the repeated application of the coin operator. If the coin operator is not applied in step 3, our state will end up in \\(\\frac{1}{\\sqrt{2}} (|0\\rangle|-2\\rangle + |1\\rangle|2\\rangle)\\) which is not what we wanted. This is because the application of the controlled shift operation entangles the coin and the walker systems, and thus there is no superposition in each term of the system"
  },
  {
    "objectID": "quantum.html#computational-implementation",
    "href": "quantum.html#computational-implementation",
    "title": "4  Quantum Walks{#sec-quantum}",
    "section": "4.3 Computational Implementation",
    "text": "4.3 Computational Implementation\nThere are 2 ways to implement the Quantum walks, which are both interesting in their own ways. But the foremost thing to tackle would be how to store an infinite vector and an infinite dimensional operator. Since we cannot do either of these simply, we instead limit our walk to a node space of \\(2n\\), and use periodic boundary conditions.\n\n\n\n\n\n\nOther Boundary Conditions\n\n\n\nOne could pick other boundary conditions too, such as the open or the absorbing boundary conditions, but both of these BCs lead to nonunitary operations, which complicate the definition and application of the gate.\n\n\n\n4.3.1 Matrix formalism\nThe first and more immediate method is to simply write down the matrix equivalent of the above operations. For the visualization of the implementations, we will assume that the walk occurs in a 1 D chain of size 4.\nThe coin is prefered to be in the \\(\\frac{1}{\\sqrt2}(|0\\rangle + i |1\\rangle)\\) when we start so that the walk proceeds symmetrically1.\n\ninit_coin = 1/√2 * (ket(1,2) - 1im * ket(2,2));\n\nThe coin operator is trivial to write,\n\nH = KrausOperators([sparse(hadamard(2)⊗I(4))]);\n\nThe left and right shift operators can be defined in the following manner.\n\nR = collect(Tridiagonal(fill(1., 3), zeros(4), zeros(3)))\nR[1, end] = 1\nL = collect(Tridiagonal(zeros(3), zeros(4), fill(1., 3)))\nL[end, 1] = 1\n\nThus the shift operator is defined as\n\nS = KrausOperators([sparse(proj(ket(1, 2)) ⊗ L + proj(ket(2, 2)) ⊗ R)]);\n\nThus, we can repeatedly apply \\(S\\circ H\\) to the initial state and accumulate the results.\n\ninit_state = proj(init_coin ⊗ ket(2,4))\nψ = [[init_state]; accumulate(1:40, init=init_state) do old, _\n    H(S(old))\nend];\n\nNow we can plot the readout statistics by partially tracing out the coin, and plotting the diagonal. The following is a walk on 61 nodes.\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4.1: Probability distribution of a Quantum Walker in time\n\n\n\n\n\n\n\n\n\nQuantum Walks are not random\n\n\n\nNote, this is a single walker, not an ensemble of walkers as is the case in classical random walks. Quantum walks (without measurement), are completely deterministic.\n\n\n\n\n4.3.2 Circuit Formalism\nWhile the matrix definition of the Quantum Walks are easy to formalize and understand, finally these need to be simulated on some sort of device which may require us to reformulate it. Further, we try to ensure that the reformulation allows for easy additions of other dynamics which we may want to study.\nThe advantages of using a Quantum Computer over a classical computer for a quantum walk should be obvious. The problem however is that the quantum walk is over a high dimensional space, and we rarely have access to such high dimensional systems which we can control easily. Instead we need to simulate such a system using the accessible 2 level systems available in quantum computers.\nLet us define the basic components of our walk.\n\n4.3.2.1 Nodes\n\nEach numbered node is then converted into its 2-ary \\(n\\) length representation denoted by \\((x_i)\\). \\(n\\) is chosen such that \\(2^n\\) &gt; \\(N\\)\nThese bitstrings are encoded into an \\(n\\) qubit computer, where each basis state in the computational basis corresponds to the node with the same bitstring.\nThe amplitude of a particular basis corresponds to the amplitude of the walker in the corresponding node\n\n\n\n4.3.2.2 Coin\n\nThe Walk Coin is a two level system, as usual\n\n\n\n4.3.2.3 Edges and Shifts\n\nSince shifts are only to adjacent nodes, the left (right) shift is equivalent of subtracting (adding) 1 from the bitstring of the state.\nFrom the Quantum adder circuit, we can set one input to be \\((0)_{n-1}1\\) and reduce the circuit to get the Quantum AddOne circuit. Shown below is the circuit for $n=4 $ \\((N=16)\\)\nWe can similarly construct the SubOne circuit, but that is simplified by noting that the subone circuit is simply the inverse of the addone circuit, and this corresponds to just inverting the circuit (all gates are unitary).”“”\n\n\nrightshift(n) = chain(\n    n, \n    map(n:-1:2) do i\n        control(1:i-1, i=&gt;X) end..., \n    put(1=&gt;X)\n)\nleftshift(n) = rightshift(n)';\n\n\nYaoPlots.plot(rightshift(4))\n\n\n\n\nFigure 4.2: Right shift circuit\n\n\n\n\n\nYaoPlots.plot(leftshift(4))\n\n\n\n\nFigure 4.3: Left shift circuit\n\n\n\n\nThe controlled shift operation is encoded as\n\nshift(n) = chain(n+1,\n    control(1, 2:n+1 =&gt; rightshift(n)),\n    put(1 =&gt; X),\n    control(1, 2:n+1 =&gt; leftshift(n)),\n    put(1 =&gt; X),\n)\n\nYaoPlots.plot(shift(4))\n\n\n\n\nFigure 4.4: Controlled shift circuit\n\n\n\n\n\n\n4.3.2.4 Coin operator\nWe can add the coin operator as usual on the first rail.\n\ncoin(n, c=Yao.H) = chain(n+1, put(1 =&gt; c))\nYaoPlots.plot(coin(4))\n\n\n\n\nFigure 4.5: Coin Operator circuit\n\n\n\n\n\n\n4.3.2.5 Evolve Circuit\nPutting these together, we get the operation for a single step of the evolution as below. Note that the top qubit rail is that of the coin, and the rest are those of the simulation of the system.\nThis circuit can be repeated to acheive any number of steps.\n\nevolve(n) = shift(n) * coin(n)\nYaoPlots.plot(evolve(4))\n\n\n\n\nFigure 4.6: Quantum walk evolve circuit\n\n\n\n\n\n\n4.3.2.6 Prepare circuit\nWhile we can already simulate the walk, an very useful helper function that we can define is the prepare circuit.\nQuantum registers are often initialized to the 0 state, and it is also easy to restart the walk from the 0 state. However, we often like to start the walk in the center of the chain instead of at node 0. Also, the coin is prefered to be in the \\(\\frac{1}{\\sqrt2}(|0\\rangle + i |1\\rangle)\\) when we start so that the walk proceeds symmetrically1.\nHence, to perform these steps, we define the following prepare subroutine.\n\nprepare(n) = chain(\n    n+1, \n    put(1=&gt;Yao.H), \n    put(1=&gt;Yao.shift(-π/2)), \n    put(n+1=&gt;X)\n)\n\nYaoPlots.plot(prepare(3))\n\n\n\n\nFigure 4.7: Initial state preparation circuit\n\n\n\n\nSimilarly plotting as before,\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4.8: Quantum walk using circuit formalism\n\n\n\nThus we can see that the two formalisms are the same."
  },
  {
    "objectID": "quantum.html#properties-of-the-walk",
    "href": "quantum.html#properties-of-the-walk",
    "title": "4  Quantum Walks{#sec-quantum}",
    "section": "4.4 Properties of the walk",
    "text": "4.4 Properties of the walk\nSimilar to the classical random walk, the mean \\(\\mu(t) = 0\\).\nHowever, a more interesting feature is that the standard deviation \\(\\sigma(t) = 0.54 t\\)1. Compare this with the classical random walk, the quantum walk has a quadratic speed up. This the reason for the quadratic speedup commonly seen in the Grover search and other Monte Carlo problems.\n\n\n\nStandard Deviation with time for the quantum(crosses) and classical random(circles) walks\n\n\n\n\n\n\n\n\n1 R. Portugal, Quantum Walks and Search Algorithms, 2nd ed. 2018 (Springer International Publishing : Imprint: Springer, Cham, 2018)."
  },
  {
    "objectID": "search.html#formalism",
    "href": "search.html#formalism",
    "title": "5  Search Algorithms{#sec-search}",
    "section": "5.1 Formalism",
    "text": "5.1 Formalism\nDefine the following\n\nDenote the readout at the \\(n^{\\text{th}}\\) measurement (at \\(t=n\\tau\\)) as \\(X_n\\).\nSelect a target node \\(\\delta\\)\nProbability of first hit in \\(n\\) steps \\(F_n = P(X_n = \\delta | X_i \\ne \\delta \\forall i \\in [0, n-1])\\)\nMean hit time \\(\\langle t_S \\rangle = \\sum_{i=0}^\\infty i F_i\\)\nSuccess probability in \\(n\\) steps \\(S_n = \\sum_{i=1}^{n}F_i = P(\\exists i \\in [0, n]| X_i = \\delta)\\)\nSurvival probability \\(=\\) Failure probability \\(= \\mathcal{S}_n = 1 - S_n\\)\nAsymptomatic versions of these terms are given by taking \\(n\\to \\infty\\)\n\n\n5.1.1 Readout in Walks\nTo identify whether a walker has hit the target node, we need to track the location of the walker as it evolves in time.\nFor the classical case, this poses no problem, as measurement does not disturb the system. In the quantum case however, we need to be a bit more careful.\nA constantly measured walker will freeze the dynamics of a quantum walker. This is known as the Quantum Zeno effect. The solution for this is to measure after every \\(\\tau\\) steps.\n\n\n\n\n\n\nReduction to classical random walk with \\(\\tau=1\\)\n\n\n\nThe quantum \\(\\tau = 1\\) case reduces the discrete time quantum walk to a classical random walk with \\(\\tau=1\\). Effectively, we apply a dephasing operator on the density matrix, dropping all off diagonal terms. Thus, we lose all effects of superposition, causing the classical random walk.\n\n\nLet us plot the readout trajectories of walkers with different paramters\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5.1: Trajectories of readouts in quantum and classical walks\n\n\n\nNote the very clear difference in the spread between the classical readout and the quantum readout for same \\(\\tau\\). Similarly note the spread between the quantum readouts for different \\(\\tau\\)s."
  },
  {
    "objectID": "search.html#markov-chains-and-walks",
    "href": "search.html#markov-chains-and-walks",
    "title": "5  Search Algorithms{#sec-search}",
    "section": "5.2 Markov Chains and Walks",
    "text": "5.2 Markov Chains and Walks\nIn the classical case, it is clear that the 1D SSRW is a markov process. In [TODO: Cite Appendix 1], we show that the quantum walk with measurement is also a markov process.\nConsequently, we can use certain results from the theory of Markov processes to compare the two walks.\n\n5.2.1 Irreducibilty and Recurrence\nUnder the usual definition of irreducibility1,\n\n\n\n\n\n\nDefinition: Irreducibility\n\n\n\nIf \\(\\forall i, j \\in S, \\exists n, m | P^n_{ij} &gt; 0, P^m_{ji}&gt;0\\), then the chain is called irreducible.\n\n\nIt is trivial that in the 1D chain, \\(n = m = |i-j|\\tau\\) satisfies the condition.\nFollowing1,\n\n\n\n\n\n\nDefinition: Recurrence\n\n\n\nIf \\(i \\in S, \\sum_{n=1}^\\infty P^n_{ii} \\to \\inf\\), then the state is called recurrent. Equivalently, \\(\\sum_n F_n \\to 1\\) for recurrent nodes. If a chain is irreducible and one of its states is recurrent, all its states are recurrent and thus the chain is called recurrent.\n\n\nIt is a well known fact that the 1D SSRW is recurrent. It is just as well known a fact that the 3D SSRW is transient1. In the quantum case, it is not as clear whether any of the available definitions of the quantum markov process is more or less better than the others. Thus, the transience of quantum walks depends on the exact definition we are working under2. In our definition however, it can be shown using symbolic computation3 that the walk is indeed transient. This poses an interesting problem."
  },
  {
    "objectID": "search.html#survival-probability",
    "href": "search.html#survival-probability",
    "title": "5  Search Algorithms{#sec-search}",
    "section": "5.3 Survival probability",
    "text": "5.3 Survival probability\nWe can thus measure and plot the \\(S_n - n\\) curve for the quantum and classical walks to compare the efficiency of these walks in the first hit problem.\nIn previous work4, the analytical solution of the success rate as a function of time is found. An analytical result for discrete time walks is harder due to the nature of the walk. However we reproduce the analytical results for the discrete time case computationally. Figure 5.2 (a)4 shows the success rate for the continuous time quantum and classical walks, and Figure 5.2 (b) shows our results for the discrete time case.\n\n\n\n\n\n\n\n(a) Success probability vs Time for both walks4\n\n\n\n\n\n\n\n(b) TODO\n\n\n\n\nFigure 5.2: Success Probability\n\n\n\n5.3.1 Observations\nIn the continuous time case:\n\nThe quantum walk has a fast rise in the initial phase but saturates at ~0.1\nThe classical walk has a slow rise, but eventually reaches 1\n\nIn the discrete time case, solved computationally:\n\nBoth walks do eventually reach 1\nThe quantum walk shows a saturation for a while before suddenly rising again\nThe classical walk shows a slow rise in the beginning phases, in contrast to the sharper rise of the quantum walk.\n\nThe observations in the continuous time case can be explained by the recurrence of the walk. While the quantum walker is faster (See ?sec-quantum), the transient nature (See Chapter 5.2.1) of the walk leads to a non zero asymptomatic failure rate. Clearly this is a problem. What this means practically, is that for the first hit problem, if the quantum walk hits the target node, it does so faster than the classical walk, but a majority of the times, it doesn’t hit the target node at all.\nThere seems to be an apparent difference between the discrete and the continuous time walks, but this is only an artifact of the finite size of the walk space. It is well known that any irreducible finite chain is recurrent5. This claim can be verified by simply increasing the size of the state space, and noting that the saturation phase in the quantum walk lasts longer.\n\n\n\n\n\n\n1 J.R. Norris, Markov Chains, 1st pbk. ed (Cambridge University Press, Cambridge, UK ; New York, 1998).\n\n\n2 M. Štefaňák, I. Jex, and T. Kiss, Physical Review Letters 100, 020501 (2008).\n\n\n3 H. Friedman, D.A. Kessler, and E. Barkai, Phys. Rev. E 95, 032141 (2017).\n\n\n4 R. Yin and E. Barkai, (2022).\n\n\n5 user940, (n.d.)."
  },
  {
    "objectID": "reset.html#formalism",
    "href": "reset.html#formalism",
    "title": "6  Stochastic Resetting{#sec-reset}",
    "section": "6.1 Formalism",
    "text": "6.1 Formalism\nA reset of the walker implies that the walker returns to its initial state, and the walk dynamics continue from there.\nHowever, we can vary when we reset the walker by considering multiple reset processes. A common reset process is the Poissonian reset, where the reset times are modelled as a poissonian process with some parameter \\(r\\). This is particularly convenient in the case of continuous time walks.\nFor the discrete walks, the geometric distribution is more natural.\n\\[t \\sim \\text{Geom}(\\gamma)\\]\nthat is, at each step, there is a \\(\\gamma\\) probability of reset.\nThis results in different dynamics, which can be seen in subsequent subsections, but it has an equally drastic effect on the recurrence of the walk.\n\n6.1.1 Recurrence and Resetting\nIn the geometric resetting case, it is clear that \\(P^n_{00} \\ge \\gamma\\), and hence \\(\\sum_n P^n_{00} \\ge \\sum_n \\gamma\\) which diverges as \\(n \\to \\infty\\). Thus regardless of the initial walk, the final walk will definitely be recurrent. Thus the motivation for resetting the quantum walk which is transient should be immediately clear.\n\n6.1.1.1 Stochastic Reset Classical Walk\nIn the classical case, the transition probabilities change to\n\\[p_{ij} = \\begin{cases}\n    (1-\\gamma) \\cdot 1/2 & |i - j| = 1 \\\\\n    \\gamma & j = r_0 \\\\\n    0 & \\text{otherwise}\n\\end{cases}\\]\nThus, the new transition matrix is modelled as\n\nγ = 0.2\nU1 = sparse(SymTridiagonal(fill(0., 31), fill(0.5, 30)))\nR = fill(0., (31, 31))\nR[21,:] .= 1\nU = sparse((1-γ) * U1 + γ * R);\n\nwhere U1 is the unchanged walk matrix and R is the reset matrix.\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6.1: Stochastic Reset Classical Walk\n\n\n\n\n\n6.1.1.2 Stochastic Reset Quantum Walk\nIn the quantum case, the evolution changes from unitary dynamics to a nonunitary CPTP map of the following form.\n\\[O_{SR}(\\rho) = (1-\\gamma)\\left(U\\rho U^\\dagger\\right) + \\gamma |r_0\\rangle\\langle r_0|\\]\nwhere \\(U\\) is the walk unitary.\n\nfunction swqw(n, γ)\n    R = collect(Tridiagonal(fill(1., n), zeros(n+1), zeros(n)))\n    R[1, end] = 1\n    L = collect(Tridiagonal(zeros(n), zeros(n+1), fill(1., n)))\n    L[end, 1] = 1\n    U = KrausOperators(\n        [sparse(proj(ket(1, 2)) ⊗ L + proj(ket(2, 2)) ⊗ R)]\n    )\n    init_coin = 1/√2 * (ket(1,2) - 1im * ket(2,2))\n    H = KrausOperators([sparse(hadamard(2)⊗I(n+1))])\n    init_state = proj(init_coin ⊗ ket(n÷2 + 1, n+1))\n    ψ = [[init_state]; accumulate(1:40, init=init_state) do old, _\n        (1-γ)*H(U(old)) + γ*proj(init_coin ⊗ ket(n÷2+6, n+1))\n    end]\n    map(enumerate(real.(diag.(ptrace.(\n        ψ, Ref([2, n+1]), Ref([1])\n    ))))) do (t, ps)\n        Plots.plot(\n            -n÷2:n÷2, ps, \n            ylims=(0, 1), xlabel=\"\\$i\\$\", \n            ylabel=\"\\$\\\\langle i|\\\\psi\\\\rangle\\$\",\n            title=\"\\$t=$(t), \\\\gamma=$(γ), r_0 = |5\\\\rangle \\$\",\n            legend=false\n        )\n    end\nend;\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6.2: Stochastic Reset Quantum Walk"
  },
  {
    "objectID": "reset.html#effect-of-resetting-on-first-hit-problem",
    "href": "reset.html#effect-of-resetting-on-first-hit-problem",
    "title": "6  Stochastic Resetting{#sec-reset}",
    "section": "6.2 Effect of Resetting on First Hit problem",
    "text": "6.2 Effect of Resetting on First Hit problem\nFor this analysis, we will consider the simpler “sharp reset” formalism1, where the reset time is sampled from a distribution\n\\[t_r \\sim \\delta(t-r\\tau)\\]\nThus we restart after \\(r\\) measurement events (at \\(t = r\\tau\\)). Once we understand the effect of this kind of reset, gaining intuition for reset times sampled differently is easier.\nThe success probability vs time can now be plotted (Figure 6.3 (a))1 for the reset case.\nNow we see that the success probability is drastically increased for both cases, but due to the ballistic nature of the quantum walk, we see that the reset quantum walk performs much better than the classical walk.\nFor a better understanding of the performance of the reset quantum walk with reference to changing reset rates (\\(r\\)) and measurement times (\\(\\tau\\)), we can plot (Figure 6.3 (b))1 the mean first hitting time vs these parameters.\n\n\n\n\n\n\n\n(a) Reset Success probability vs Time1\n\n\n\n\n\n\n\n(b) Effect of \\(r\\) and \\(\\tau\\) on mean hitting time1\n\n\n\n\nFigure 6.3: Sharp Reset Quantum Walk\n\n\n\n6.2.1 Observations\n\nDeterministic restart leads to zero asymptomatic failure rate\nEager restarting leads to walker never reaching \\(\\delta\\), reducing success rates drastically\nCautious restart reduces the effect of restart, reducing success rates.\nThere exists an optimal \\(r\\), but this needs to be optimized, which is non trivial for general \\(\\tau\\) and graph structures.\n\n\n\n\n\n\n\nCan stochastic restarting be better than sharp reset?\n\n\n\nNo, because even if \\(\\langle r\\rangle = r_{\\text{optimal}}\\), \\(\\langle t_f\\rangle &gt; \\langle t_f\\rangle_{\\text{optimal}}\\) due to the non-monotonic nature of the curve"
  },
  {
    "objectID": "reset.html#sharp-reset-for-discrete-time-walks",
    "href": "reset.html#sharp-reset-for-discrete-time-walks",
    "title": "6  Stochastic Resetting{#sec-reset}",
    "section": "6.3 Sharp Reset for Discrete time walks",
    "text": "6.3 Sharp Reset for Discrete time walks\nFor discrete time walks, the sharp reset walk is given by\n\\[|\\psi_t\\rangle = U^{t - r_l\\tau} (|c_\\text{init}\\rangle \\otimes |0\\rangle)\\]\nwhere \\(r_l \\tau\\) was the time of last reset.\nEquivalently, in the circuit model, the reset circuit is considered to be a measure followed by postprocess where we apply the appropriate unitary rotation to rotate to \\(|\\psi_0\\rangle\\).\n\n\n\n\n\n\n\nP(hit) vs Time\n\n\n\n\n\n\n\n\\(\\langle T_{hit}\\rangle\\) vs \\(\\gamma\\)\n\n\n\n\nFigure 6.4: Sharp Reset Quantum Walk\n\n\nOur results are plotted in Figure 6.4. Note the similarity between the curves. However, also note the difference between the non reset curve, where in the discrete case, success probability still reaches 1, this can be attributed, as before, to the finiteness of the walk space."
  },
  {
    "objectID": "reset.html#the-problem-in-the-solution",
    "href": "reset.html#the-problem-in-the-solution",
    "title": "6  Stochastic Resetting{#sec-reset}",
    "section": "6.4 The Problem in the Solution",
    "text": "6.4 The Problem in the Solution\nAs discussed before, reset rates which are very high or low can end up being detrimental to the success times of the walk. Secondly, there is no clear path as to how to optimize the reset parameter for arbitrary graph structures.\nJust as we harnessed the power of quantum superposition to speed up the walk, can we similarly have a superposition between the reset and evolution?\n\n\n\n\n\n\n1 R. Yin and E. Barkai, (2022)."
  },
  {
    "objectID": "qreset.html#sec-qreset-formalism",
    "href": "qreset.html#sec-qreset-formalism",
    "title": "7  Quantum Resetting by Superposition{#sec-qreset}",
    "section": "7.1 Formalism",
    "text": "7.1 Formalism\nOn a finite 1D chain of length \\(2N + 1\\), define the following - - Reset operation - \\(\\mathcal{R}\\) by the Kraus operators \\(\\{\\mathcal{R_i} = |r_0\\rangle\\langle i|\\}_{i\\in [-N, N]}\\) on \\(\\mathcal{H}_W\\) - Evolve operation - \\(\\mathcal{U}\\) by the unitary operation \\(S\\circ H\\) on \\(\\mathcal{H}_C\\otimes\\mathcal{H}_W\\) - Attach another two level coin - states denoted by \\(|0\\rangle\\) and \\(|1\\rangle\\). Resulting state lies in \\(\\mathcal{H}_R\\otimes\\mathcal{H}_C\\otimes\\mathcal{H}_W\\) - Controlled reset operation - \\(\\mathcal{E}\\) by the Kraus operators \\(\\{\\mathcal{E}_i = |0\\rangle\\langle 0|\\otimes I_2 \\otimes \\mathcal{R}_i + \\frac{1}{\\sqrt N} |1\\rangle\\langle 1|\\otimes \\mathcal{U}\\}_{i\\in [-N, N]}\\). See TODO:appendix for proof that this set of Krauss operators represents a CPTP map. - A reset coin operator \\(\\Gamma(\\gamma) = \\begin{bmatrix}\\sqrt{1-\\gamma} & \\sqrt{\\gamma} \\\\ \\sqrt{\\gamma} & -\\sqrt{1- \\gamma}\\end{bmatrix}\\) on \\(\\mathcal{H}_R\\) - One step of the resulting walk is defined as \\(\\mathcal{E} \\circ \\left(\\Gamma \\otimes I_2 \\otimes I_{2N+1}\\right)\\)\nThe initial motivation for such a formalism comes from Anubhav’s1 master thesis, where a similar formalism was applied to a qubit system. The dominant motivation is the faster convergence in the quantum case, which was confirmed in the qubit case. However, the current problem we are considering has drastically changed the methods of exploration and the property we want to optimize.\n\n7.1.1 Interpretation of \\(\\gamma\\) and dependence on initial condition of the coin\nIn the stochastic resetting \\(\\gamma\\) is understood as the “rate” of resetting. However, this is no longer accurate for the quantum case. Consider the case for \\(\\gamma = 0\\). Then, the Gammamard operator \\(\\Gamma = \\begin{bmatrix}1 & 0\\\\ 0 & -1\\end{bmatrix}\\). This does not automatically imply that the reset never occurs; we also require that the initial state of the reset coin is \\(|0\\rangle\\). If the initial state of the reset coin is \\(|1\\rangle\\), this corresponds to the always reset case. Thus, \\(\\gamma\\) is better understood as the probability that given the last step was a reset, what is the probabilty this step is an evolve, and vice versa. Thus, it is not immediately obvious how we can compare the reset mechanisms for a given \\(\\gamma\\). Nor is it obvious how the initial state of the reset coin finally affects the success probability and such, and needs to be numerically checked.\n\n\n7.1.2 Resetting of the walker coin\nIn our specific formalism (Section 7.1), we have only applied the reset operation on the walker \\(\\mathcal{H}_W\\). One could also reset the walker coin \\(\\mathcal{H}_C\\) and see what happens. In our current formalism, there is no entanglement broken between the two coins, but there is no apriori understanding of how this may (or may not) affect the walk."
  },
  {
    "objectID": "qreset.html#computational-implementation",
    "href": "qreset.html#computational-implementation",
    "title": "7  Quantum Resetting by Superposition{#sec-qreset}",
    "section": "7.2 Computational Implementation",
    "text": "7.2 Computational Implementation\nImplementations of \\(\\mathcal{U}, U, H\\) follow as before. The \\(\\mathcal{E}\\) operation is implemented as\n\nfunction €(n, r₀)\n    ks = map(1:n) do i\n        (1/√n * [1 0; 0 0] ⊗ (S(n)*H(n))) +\n        [0 0; 0 1] ⊗ I(2) ⊗ real(ket(r₀,n)*bra(i,n))\n    end\n    return KrausOperators(sparse.(ks))\nend;\n\nThe gammamard operation \\(\\Gamma\\) is defined as\n\nΓ(γ) = [\n    √(1-γ)  √γ;\n    √γ      -√(1-γ)\n];\n\nWe take the initial reset coin to be \\((S(-\\pi/2)\\circ\\Gamma(\\gamma))|0\\rangle\\) for the same reason as in the quantum walk\n\nreset_init(γ) = [1 0; 0 -1im]*gammamard(γ)*ket(1, 2);"
  },
  {
    "objectID": "qreset.html#results",
    "href": "qreset.html#results",
    "title": "7  Quantum Resetting by Superposition{#sec-qreset}",
    "section": "7.3 Results",
    "text": "7.3 Results\n\n7.3.1 What the walk looks like\nFor the specific choice of initial reset coin as \\(1/\\sqrt{2}\\left(|0\\rangle - i|1\\rangle\\right)\\) and \\(\\gamma=0.2\\), the quantum reset walk looks like Figure 7.1.\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.1: Quantum Reset Walk"
  },
  {
    "objectID": "qreset.html#section",
    "href": "qreset.html#section",
    "title": "7  Quantum Resetting by Superposition{#sec-qreset}",
    "section": "7.4 ",
    "text": "7.4 \n\n\n\n\n\n\n1 A. Srivastava, Resetting Quantum Systems Through Superposition of Evolution, PhD thesis, IISER Mohali, 2021."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "8  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "1 M.\nŠtefaňák, I. Jex, and T. Kiss, Physical Review Letters\n100, 020501 (2008).\n\n\n2 R. Yin and E.\nBarkai, (2022).\n\n\n3 user940,\n(n.d.).\n\n\n4 K.P.\nGriffin, S.J. Suresh, T.J. Flint, and W.H.R. Chan, (2019).\n\n\n5 M. Goldsmith, G.\nGarcía-Pérez, J. Malmi, M.A.C. Rossi, H. Saarinen, and S. Maniscalco,\n(2022).\n\n\n6 X. Bonnetain, A.\nChailloux, A. Schrottenloher, and Y. Shen, (2022).\n\n\n7 S.A. Ortega and\nM.A. Martin-Delgado, (2022).\n\n\n8 H.\nFriedman, D.A. Kessler, and E. Barkai, Phys. Rev. E 95,\n032141 (2017).\n\n\n9 D.\nPsaltis, F. Özel, L. Medeiros, P. Christian, J. Kim, C. Chan, L.J.\nConway, C.A. Raithel, D. Marrone, and T.R. Lauer, ApJ\n928, 55 (2022).\n\n\n10\nQiskit, Quantum Walk Search Algorithm (n.d.).\n\n\n11 J.R. Norris, Markov Chains, 1st pbk. ed\n(Cambridge University Press, Cambridge, UK ; New York, 1998).\n\n\n12 P. Glasserman, Monte Carlo Methods in\nFinancial Engineering (Springer, New York, 2004).\n\n\n13 N. Metropolis, (n.d.).\n\n\n14 A. Srivastava, Resetting Quantum\nSystems Through Superposition of\nEvolution, PhD thesis, IISER Mohali, 2021.\n\n\n15 L.S.\nde Souza, J.H.A. de Carvalho, and T.A.E. Ferreira, in 2019 8th\nBrazilian Conference on\nIntelligent Systems (BRACIS)\n(IEEE, Salvador, Brazil, 2019), pp. 836–841.\n\n\n16 M. Bae\nand W.O. Krawec, (2021).\n\n\n17 S.\nMukherjee, IEEE Trans. Quantum Eng. 3, 1 (2022).\n\n\n18 R. Portugal, Quantum\nWalks and Search\nAlgorithms, 2nd ed. 2018 (Springer International\nPublishing : Imprint: Springer, Cham, 2018)."
  }
]